---
title: 'leetcode 416. Partition Equal Subset Sum | medium | backtrack | dynamic-programming | javascript'
date: '2022-10-19'
tags: ['medium', 'backtrack', 'dynamic-programming']
draft: false
summary: 'leetcode 416. Partition Equal Subset Sum | medium | backtrack | dynamic-programming | javascript'
layout: PostLayout
readTime: '10 minute read'
---

## üóíÔ∏è Problems

[Partition Equal Subset Sum - LeetCode](https://leetcode.com/problems/partition-equal-subset-sum/)

```
Given a non-empty array nums containing only positive integers,
find if the array can be partitioned into two subsets such
that the sum of elements in both subsets is equal.
```

```
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

### Constraints:

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## üîÄ ü§î First attempt

The first algorithm that I came up with is the backtrack algorithm.
But the input size is upto `200`. The backtrack algorithm won't work.

```javascript
var canPartition = function (nums) {
  const total = nums.reduce((a, b) => a + b, 0)
  if (total % 2 === 1) return false

  const target = total / 2
  const N = nums.length

  const dp = (remain, cur, index) => {
    if (remain === 0) {
      if (cur.length < N) return true
      return false
    }
    if (remain < 0) return false

    let local = false
    for (let i = index; i < N; i += 1) {
      cur.push(nums[i])
      local = local || dp(remain - nums[i], cur, i + 1)
      cur.pop()
    }
    return local
  }

  return dp(target, [], 0)
}
```

Î∞îÎ°ú TLE Î∞úÏÉùÌï©ÎãàÎã§.
Ïó¨Í∏∞Ïóê `memo` Î∂ôÏùº ÏàòÎèÑ ÏûàÍ≤†ÏßÄÎßå knapsackÏùÑ Ïù¥Ïö©Ìïú dynamic programming Î∞©Î≤ï ÌíÄÏù¥ÎèÑ Í∞ÄÎä•ÌïòÎã§Í≥† Ìï©ÎãàÎã§.

## ‚ú® Idea

- `nums[]` Ìï©ÏùÑ Î∞òÏù¥ ÎêòÎèÑÎ°ù ÌïòÎäî subset Ïù¥ ÏûàÎäîÍ∞Ä ?
  - `nums[]` Ï§ëÏóêÏÑú ÏÑ†ÌÉùÌï¥ÏÑú ÌÉÄÏºì Î¨¥Í≤å (Ï£ºÏñ¥ÏßÑ Ï¥ùÌï© Î¨¥Í≤å /2)Î•º ÎßåÎì§ Ïàò ÏûàÎäîÍ∞Ä ?
- 01 Knapsack
  - ÌÉÄÏºì Î¨¥Í≤å : Ï£ºÏñ¥ÏßÑ Î¨¥Í≤å / 2
  - Í∞Å Î¨ºÍ±¥ Î¨¥Í≤å : `nums[]`
  - `dp[n][w]` : Î¨ºÍ±¥ `[1,...,n]` Ïù¥Ïö©Ìï¥ÏÑú Î¨¥Í≤å w Î•º ÍΩâ Ï±ÑÏö∏ Ïàò ÏûàÎäîÍ∞Ä ?

## üçÄ Intuition

### basecase

Î¨¥Í≤åÍ∞Ä 0Ïù¥ÎùºÎ©¥ ÏïÑÎ¨¥Îü∞ ÏÑ†ÌÉùÏùÑ ÌïòÏßÄ ÏïäÏïÑÎèÑ Î™©Ìëú Îã¨ÏÑ±Ìï®.

```javascript
for (let n = 0; n <= N; n += 1) {
  dp[n][0] = true
}
```

### üï∏Ô∏èüí° ÏÉÅÌÉú Ï†ÑÏù¥ Î∞©Ï†ïÏãù

ÌòÑÏû¨ ÏÑ†ÌÉùÏùÑ Í≤∞Ï†ïÌï¥ÏïºÌïòÎäî `nums[n-1]` ÌïòÎÇòÎßåÏúºÎ°ú limit Î¨¥Í≤å `w` Î≥¥Îã§ ÌÅ¨Îã§Î©¥ ÏÑ†ÌÉù Í≤∞Ï†ïÏùÑ Ìï† Ïàò ÏóÜÏúºÎØÄÎ°ú Î∞îÎ°ú Ïù¥Ï†Ñ Í≤∞Í≥ºÏôÄ ÎèôÏùºÌï®.

```javascript
if (nums[n - 1] > w) {
  dp[n][w] = dp[n - 1][w]
}
```

`nums[c-1]` ÏÑ†ÌÉùÏùÑ ÌïòÎäî Í≤ΩÏö∞ÏóêÎäî

- ÏÑ†ÌÉùÌïòÏßÄ ÏïäÍ≥† Ïù¥Ï†ÑÏóê Ïù¥ÎØ∏ ÏÑ±Í≥µÌïú Í≤ΩÏö∞ `dp[n-1][w]`
- `nums[n-1]` ÏùÑ ÎÑ£ÏùÄ Í≤ΩÏö∞, `nums[n-1]` ÏùÑ ÎÑ£ÏóàÏúºÎØÄÎ°ú Ïù¥ Î¨¥Í≤åÎ•º Î∫∏ Ïù¥Ï†Ñ Í≤∞Í≥ºÏóê Îî∞ÎùºÏÑú Í≤∞Í≥ºÍ∞Ä Í≤∞Ï†ïÎê®. `dp[n-1][w - nums[n-1]]`

```javascript
            } else {
                dp[n][w] = dp[n-1][w] || dp[n-1][w - nums[n-1]];
            }
```

## üî•‚¨ÜÔ∏èüï∏Ô∏è My Solution

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function (nums) {
  const total = nums.reduce((a, b) => a + b, 0)
  if (total % 2 === 1) return false

  const W = total / 2

  const N = nums.length
  const dp = Array(N + 1)
    .fill(null)
    .map((_) => Array(W + 1).fill(false))

  for (let n = 0; n <= N; n += 1) {
    dp[n][0] = true
  }

  for (let n = 1; n <= N; n += 1) {
    for (let w = 1; w <= W; w += 1) {
      if (nums[n - 1] > w) {
        dp[n][w] = dp[n - 1][w]
      } else {
        dp[n][w] = dp[n - 1][w] || dp[n - 1][w - nums[n - 1]]
      }
    }
  }

  return dp[N][W]
}
```
